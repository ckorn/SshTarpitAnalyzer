@inject HttpClient Http
@page "/sshtarpit"

<h3>SshTarpit</h3>

@*<FileEdit @ref="fileEdit" Changed="@OnChanged" MaxMessageSize="99999999" />*@
@*<BlazorInputFile.InputFile OnChange="HandleFileSelected" MaxMessageSize="99999999" />*@

@*@if (file != null)
{
<p>Name: @file.Name</p>
<p>Size in bytes: @file.Size</p>
<p>Last modified date: @file.LastModified.ToShortDateString()</p>
<p>Content type (not always supplied by the browser): @file.Type</p>
}

<p>@status</p>*@

<Field Horizontal="true">
    <FieldLabel ColumnSize="ColumnSize.Is2">Pastebin raw url:</FieldLabel>
    <FieldBody ColumnSize="ColumnSize.Is10">
        <TextEdit @bind-Text="@sshTarpitLogUrl"></TextEdit>
    </FieldBody>
</Field>

<Button Clicked="@(async () => await HandleRedraw())">Analyze log</Button>
<Button Clicked="@(async () => await HandleRedraw(true))">Group by 10 seconds</Button>

<p>@connections</p>

<LineChart @ref="lineChart" TItem="double" />

@code {
    FileEdit fileEdit;
    LineChart<double> lineChart;
    IReadOnlyCollection<ConnectionInformation> connectionInformationList;
    string sshTarpitLog;
    string sshTarpitLogUrl;
    ILogFileParser logFileParser = new LogFileParser();
    IFileListEntry file;
    string status;
    string connections;

    async Task HandleFileSelected(IFileListEntry[] files)
    {
        file = files.FirstOrDefault();
        if (file != null)
        {
            // Just load into .NET memory to show it can be done
            // Alternatively it could be saved to disk, or parsed in memory, or similar
            var ms = new MemoryStream();
            await file.Data.CopyToAsync(ms);

            status = $"Finished loading {file.Size} bytes from {file.Name}";
        }
    }

    async Task OnChanged(FileChangedEventArgs e)
    {
        try
        {
            foreach (IFileEntry file in e.Files)
            {
                // A stream is going to be the destination stream we're writing to.
                using (MemoryStream stream = new MemoryStream())
                {
                    // Here we're telling the FileEdit where to write the upload result
                    await file.WriteToStreamAsync(stream);

                    // Once we reach this line it means the file is fully uploaded.
                    // In this case we're going to offset to the beginning of file
                    // so we can read it.
                    stream.Seek(0, SeekOrigin.Begin);

                    // Use the stream reader to read the content of uploaded file,
                    // in this case we can assume it is a textual file.
                    using (StreamReader reader = new StreamReader(stream))
                    {
                        sshTarpitLog = await reader.ReadToEndAsync();
                    }
                }
            }
        }
        finally
        {
            this.StateHasChanged();
        }
    }

    async Task HandleRedraw()
    {
        this.connectionInformationList = await GetConnectionInformationList();
        await HandleRedraw(false);
    }

    async Task HandleRedraw(bool group)
    {
        //if (file == null)
        //{
        //    return;
        //}
        //using (StreamReader reader = new StreamReader(file.Data))
        //{
        //    this.sshTarpitLog = await reader.ReadToEndAsync();
        //}
        await lineChart.Clear();
        List<(int seconds, int count)> logFileDataList = await Task.Run<List<(int seconds, int count)>>(() => LogFileData(connectionInformationList, group));
        List<string> labelList = new();
        List<double> dataList = new();
        foreach ((int seconds, int count) in logFileDataList)
        {
            string label = $"{seconds.ToString()} s";
            if (seconds >= 60)
            {
                int minutes = seconds / 60;
                int secondsPart = seconds % 60;
                label = $"{minutes}m {secondsPart}s";
            }
            labelList.Add(label);
            dataList.Add(count);
        }
        await lineChart.AddLabelsDatasetsAndUpdate(labelList, GetLineChartDataset(dataList));
        this.connections = $"Connections: {connectionInformationList.Count}";
    }

    LineChartDataset<double> GetLineChartDataset(List<double> dataList)
    {
        return new LineChartDataset<double>
        {
            Label = "# of seconds in the tarpit",
            Data = dataList,
            BackgroundColor = backgroundColors,
            BorderColor = borderColors,
            Fill = true,
            PointRadius = 2,
            BorderDash = new List<int> { }
        };
    }

    List<string> backgroundColors = new List<string> { ChartColor.FromRgba(255, 99, 132, 0.2f), ChartColor.FromRgba(54, 162, 235, 0.2f), ChartColor.FromRgba(255, 206, 86, 0.2f), ChartColor.FromRgba(75, 192, 192, 0.2f), ChartColor.FromRgba(153, 102, 255, 0.2f), ChartColor.FromRgba(255, 159, 64, 0.2f) };
    List<string> borderColors = new List<string> { ChartColor.FromRgba(255, 99, 132, 1f), ChartColor.FromRgba(54, 162, 235, 1f), ChartColor.FromRgba(255, 206, 86, 1f), ChartColor.FromRgba(75, 192, 192, 1f), ChartColor.FromRgba(153, 102, 255, 1f), ChartColor.FromRgba(255, 159, 64, 1f) };

    async Task<IReadOnlyCollection<ConnectionInformation>> GetConnectionInformationList()
    {
        if (string.IsNullOrEmpty(this.sshTarpitLogUrl))
        {
            return new List<ConnectionInformation>();
        }
        this.sshTarpitLog = await Http.GetStringAsync(this.sshTarpitLogUrl);
        IReadOnlyCollection<ConnectionInformation> connectionInformationList = logFileParser.Parse(sshTarpitLog);
        return connectionInformationList;
    }

    List<(int seconds, int count)> LogFileData(IReadOnlyCollection<ConnectionInformation> connectionInformationList, bool group)
    {
        List<(int seconds, int count)> ret = new();
        int groupPerSeconds = 1;
        if (group)
        {
            groupPerSeconds = 10;
        }
        foreach (var grouped in connectionInformationList
            .GroupBy(x => ((int)x.Duration.TotalSeconds) / groupPerSeconds)
            .OrderBy(x => x.Key))
        {
            int count = grouped.Count();
            int xValue = (group) ? (grouped.Key * 10) + 10 : grouped.Key;
            ret.Add((xValue, count));
        }
        return ret;
    }
}
